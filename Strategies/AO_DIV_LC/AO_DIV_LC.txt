// This source code is subject to the terms of the Mozilla Public License 2.0 at https://mozilla.org/MPL/2.0/
// Â© sammie123567858

//@version=5
strategy("AO_DIV_LC", overlay=true, margin_long=100, margin_short=100, process_orders_on_close = true, max_bars_back=5000, pyramiding = 0)




//THE DESCRIPTION BELOW IS FOR YOUR REFERENCE


// INDICATORS

// * <ema>, <time chart >
// * <zigzag >
// * Lorentzian classification 
// * <hidden> & <regular> AO div.



//buy entry 2 (includes logic from HIGH_WINS_DIV)

// when LC green label at(shift 1) 
// & shift 1 close above ema (if no ema chosen then ema condition will not apply) 
// & price low is below ema (if ema checked)
// & regular or hidden (as per ao div chosen in option) buy ao div within <x> bars before shift 1 (optional)
// the div second high should be the highest high among the <x> bars.
// enter buy at shift 1 close 


// buy exit 

// stop loss below last zigzag swing low 
// or stop loss below div high/low if ao div is checked
// take profit : risk:reward 
// or close when sell entry is done 
// or close when kernel color changes 


// NOTE ABOUT EXITS:
//if tp & sl input is true but close condition is false, it will work for single trades (1 trade at a time)
//if close condition is true but sl & tp exit is false, it will work for single & multiple trades at a time (if you want multiple trades to be taken, change pyramiding to anything more than 0)
//if both are true, it will only work for single trades. the entries will be exited based on if the sl/tp or close condition gets triggered first



//-----------------------------------------------------------------------------------------------------------------------------------










//trade condition inputs
priceCloseEntryInput = input.bool(false, 'Ema Price Close Condition?', group = 'entry Settings', tooltip = "when price closes above/below ma.")
priceExtEntryInput = input.bool(false, 'Ema Price Low/High Condition?', group = 'entry Settings', tooltip = "when price high/low is above/below ma")
lorenzeEntryInput = input.bool(true, 'Lorentzian Condition?', group = 'entry Settings', tooltip = 'when a green/red label comes')
rDivEntryInput = input.bool(true, 'Reg Div Condition?', group = 'entry Settings', tooltip = 'checks if a regular ao divergence has come. atleast 1 other entry condition must be checked for this to work')
hDivEntryInput = input.bool(false, 'Hid Div Condition?', group = 'entry Settings', tooltip = 'checks if a hidden ao divergence has come. atleast 1 other entry condition must be checked for this to work')


entryShiftInput = input.int(0, 'Entry Shift', minval = 0, group = 'entry Settings', tooltip = 'shift on which selected entry condition/s must be true.')
divShiftInput = input.int(30, 'X Bars From Divergence', minval = 1, group = 'entry Settings', tooltip = 'the LC Label must come X bars from the divergence')
lotsInput = input.int(1, 'Lots', minval = 1, group = 'entry Settings')


useSLTPExitInput = input.bool(true, 'Use SL & TP Exit?', group = 'exit Settings', tooltip = 'use ZZ SL and Risk-Reward Based TP. only works when there is 1 trade at a time')
oppositeTradeExitInput = input.bool(false, 'Close Trade/s when Opposite Trade Opens?', group = 'exit Settings', tooltip = 'close buy trade/s when a sell entry gets opened & vice versa. this works when there is 1 or more trades running. If you want to open more than 1 trade a time, change pyramiding to anything more than 0.')
tpRatioInput = input.float(1, 'TP Ratio', minval=1, group = 'exit Settings')
useZZSLExitInput = input.bool(false, 'Use ZigZag SL?', group = 'exit Settings', tooltip = 'when this is checked, the sl will be the latest zz high/low')
useRDivSLExitInput = input.bool(true, '2nd High/Low (for Reg Div) SL?', group = 'exit Settings', tooltip = "the sl will be the divergence's 2nd high/low")
useH1DivSLExitInput = input.bool(false, '1st High/Low (for Hid Div) SL?', group = 'exit Settings', tooltip = "the sl will be the divergence's 1st high/low")
useH2DivSLExitInput = input.bool(false, '2nd High/Low (for Hid Div) SL?', group = 'exit Settings', tooltip = "the sl will be the divergence's 2nd high/low")










 

//--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------


import jdehorty/MLExtensions/2 as ml
import jdehorty/KernelFunctions/2 as kernels


type Settings
    float source
    int neighborsCount
    int maxBarsBack
    int featureCount
    int colorCompression
    bool showExits
    bool useDynamicExits

type Label
    int long
    int short
    int neutral

type FeatureArrays
    array<float> f1
    array<float> f2
    array<float> f3
    array<float> f4
    array<float> f5

type FeatureSeries
    float f1
    float f2
    float f3
    float f4
    float f5

type MLModel
    int firstBarIndex
    array<int> trainingLabels
    int loopSize
    float lastDistance
    array<float> distancesArray
    array<int> predictionsArray
    int prediction

type FilterSettings 
    bool useVolatilityFilter
    bool useRegimeFilter
    bool useAdxFilter
    float regimeThreshold
    int adxThreshold

type Filter
    bool volatility
    bool regime
    bool adx 

// ==========================
// ==== Helper Functions ====
// ==========================

series_from(feature_string, _close, _high, _low, _hlc3, f_paramA, f_paramB) =>
    switch feature_string
        "RSI" => ml.n_rsi(_close, f_paramA, f_paramB)
        "WT" => ml.n_wt(_hlc3, f_paramA, f_paramB)
        "CCI" => ml.n_cci(_close, f_paramA, f_paramB)
        "ADX" => ml.n_adx(_high, _low, _close, f_paramA)

get_lorentzian_distance(int i, int featureCount, FeatureSeries featureSeries, FeatureArrays featureArrays) =>
    switch featureCount
        5 => math.log(1+math.abs(featureSeries.f1 - array.get(featureArrays.f1, i))) + 
             math.log(1+math.abs(featureSeries.f2 - array.get(featureArrays.f2, i))) + 
             math.log(1+math.abs(featureSeries.f3 - array.get(featureArrays.f3, i))) + 
             math.log(1+math.abs(featureSeries.f4 - array.get(featureArrays.f4, i))) + 
             math.log(1+math.abs(featureSeries.f5 - array.get(featureArrays.f5, i)))
        4 => math.log(1+math.abs(featureSeries.f1 - array.get(featureArrays.f1, i))) +
             math.log(1+math.abs(featureSeries.f2 - array.get(featureArrays.f2, i))) +
             math.log(1+math.abs(featureSeries.f3 - array.get(featureArrays.f3, i))) +
             math.log(1+math.abs(featureSeries.f4 - array.get(featureArrays.f4, i)))
        3 => math.log(1+math.abs(featureSeries.f1 - array.get(featureArrays.f1, i))) +
             math.log(1+math.abs(featureSeries.f2 - array.get(featureArrays.f2, i))) +
             math.log(1+math.abs(featureSeries.f3 - array.get(featureArrays.f3, i)))
        2 => math.log(1+math.abs(featureSeries.f1 - array.get(featureArrays.f1, i))) +
             math.log(1+math.abs(featureSeries.f2 - array.get(featureArrays.f2, i)))

// ================  
// ==== Inputs ==== 
// ================ 

// Settings Object: General User-Defined Inputs
Settings settings = 
 Settings.new(
   input.source(title='Source', defval=close, group="LC General Settings", tooltip="Source of the input data"),
   input.int(title='Neighbors Count', defval=8, group="LC General Settings", minval=1, maxval=100, step=1, tooltip="Number of neighbors to consider"),
   input.int(title="Max Bars Back", defval=2000, group="LC General Settings"),
   5,
   input.int(title="Color Compression", defval=1, group="LC General Settings", minval=1, maxval=10, tooltip="Compression factor for adjusting the intensity of the color scale."),
   input.bool(title="Show Default Exits", defval=false, group="LC General Settings", tooltip="Default exits occur exactly 4 bars after an entry signal. This corresponds to the predefined length of a trade during the model's training process.", inline="exits"),
   input.bool(title="Use Dynamic Exits", defval=false, group="LC General Settings", tooltip="Dynamic exits attempt to let profits ride by dynamically adjusting the exit threshold based on kernel regression logic.", inline="exits")
 )
   
// Trade Stats Settings
// Note: The trade stats section is NOT intended to be used as a replacement for proper backtesting. It is intended to be used for calibration purposes only.
showTradeStats = input.bool(true, 'Show Trade Stats', tooltip='Displays the trade stats for a given configuration. Useful for optimizing the settings in the Feature Engineering section. This should NOT replace backtesting and should be used for calibration purposes only. Early Signal Flips represent instances where the model changes signals before 4 bars elapses; high values can indicate choppy (ranging) market conditions.', group="LC General Settings")
useWorstCase = input.bool(false, "Use Worst Case Estimates", tooltip="Whether to use the worst case scenario for backtesting. This option can be useful for creating a conservative estimate that is based on close prices only, thus avoiding the effects of intrabar repainting. This option assumes that the user does not enter when the signal first appears and instead waits for the bar to close as confirmation. On larger timeframes, this can mean entering after a large move has already occurred. Leaving this option disabled is generally better for those that use this indicator as a source of confluence and prefer estimates that demonstrate discretionary mid-bar entries. Leaving this option enabled may be more consistent with traditional backtesting results.", group="LC General Settings")

// Settings object for user-defined settings
FilterSettings filterSettings =
 FilterSettings.new(
   true,
   true,
   false,
   -0.1,
   20
 )

// Filter object for filtering the ML predictions
Filter filter =
 Filter.new(
   ml.filter_volatility(1, 10, filterSettings.useVolatilityFilter), 
   ml.regime_filter(ohlc4, filterSettings.regimeThreshold, filterSettings.useRegimeFilter),
   ml.filter_adx(settings.source, 14, filterSettings.adxThreshold, filterSettings.useAdxFilter)
  )

// Feature Variables: User-Defined Inputs for calculating Feature Series. 
f1_string = "RSI"
f1_paramA = 14
f1_paramB = 1
f2_string = "WT"
f2_paramA = 10
f2_paramB = 11
f3_string = "CCI"
f3_paramA = 20
f3_paramB = 1
f4_string = "ADX"
f4_paramA = 20
f4_paramB = 2
f5_string = "RSI"
f5_paramA = 9
f5_paramB = 1

// FeatureSeries Object: Calculated Feature Series based on Feature Variables
featureSeries = 
 FeatureSeries.new(
   series_from(f1_string, close, high, low, hlc3, f1_paramA, f1_paramB), // f1
   series_from(f2_string, close, high, low, hlc3, f2_paramA, f2_paramB), // f2 
   series_from(f3_string, close, high, low, hlc3, f3_paramA, f3_paramB), // f3
   series_from(f4_string, close, high, low, hlc3, f4_paramA, f4_paramB), // f4
   series_from(f5_string, close, high, low, hlc3, f5_paramA, f5_paramB)  // f5
 )

// FeatureArrays Variables: Storage of Feature Series as Feature Arrays Optimized for ML
// Note: These arrays cannot be dynamically created within the FeatureArrays Object Initialization and thus must be set-up in advance.
var f1Array = array.new_float()
var f2Array = array.new_float()
var f3Array = array.new_float()
var f4Array = array.new_float()
var f5Array = array.new_float()
array.push(f1Array, featureSeries.f1)
array.push(f2Array, featureSeries.f2)
array.push(f3Array, featureSeries.f3)
array.push(f4Array, featureSeries.f4)
array.push(f5Array, featureSeries.f5)

// FeatureArrays Object: Storage of the calculated FeatureArrays into a single object
featureArrays = 
 FeatureArrays.new(
  f1Array, // f1
  f2Array, // f2
  f3Array, // f3
  f4Array, // f4
  f5Array  // f5
 )

// Label Object: Used for classifying historical data as training data for the ML Model
Label direction = 
 Label.new(
   long=1, 
   short=-1, 
   neutral=0
  )

// Derived from General Settings
maxBarsBackIndex = last_bar_index >= settings.maxBarsBack ? last_bar_index - settings.maxBarsBack : 0

// EMA Settings 
useEmaFilter = false
emaPeriod = 200
isEmaUptrend = useEmaFilter ? close > ta.ema(close, emaPeriod) : true
isEmaDowntrend = useEmaFilter ? close < ta.ema(close, emaPeriod) : true
useSmaFilter = false
smaPeriod = 200
isSmaUptrend = useSmaFilter ? close > ta.sma(close, smaPeriod) : true
isSmaDowntrend = useSmaFilter ? close < ta.sma(close, smaPeriod) : true

// Nadaraya-Watson Kernel Regression Settings
useKernelFilter = input.bool(true, "Trade with Kernel", group="LC Kernel Settings", inline="kernel")
showKernelEstimate = input.bool(true, "Show Kernel Estimate", group="LC Kernel Settings", inline="kernel")
useKernelSmoothing = input.bool(false, "Enhance Kernel Smoothing", tooltip="Uses a crossover based mechanism to smoothen kernel color changes. This often results in less color transitions overall and may result in more ML entry signals being generated.", inline='1', group='LC Kernel Settings')
h = input.int(8, 'Lookback Window', minval=3, tooltip='The number of bars used for the estimation. This is a sliding value that represents the most recent historical bars. Recommended range: 3-50', group="LC Kernel Settings", inline="kernel")
r = input.float(8., 'Relative Weighting', step=0.25, tooltip='Relative weighting of time frames. As this value approaches zero, the longer time frames will exert more influence on the estimation. As this value approaches infinity, the behavior of the Rational Quadratic Kernel will become identical to the Gaussian kernel. Recommended range: 0.25-25', group="LC Kernel Settings", inline="kernel")
x = input.int(25, "Regression Level", tooltip='Bar index on which to start regression. Controls how tightly fit the kernel estimate is to the data. Smaller values are a tighter fit. Larger values are a looser fit. Recommended range: 2-25', group="LC Kernel Settings", inline="kernel")
lag = input.int(2, "Lag", tooltip="Lag for crossover detection. Lower values result in earlier crossovers. Recommended range: 1-2", inline='1', group='LC Kernel Settings')

// Display Settings
showBarColors = true
showBarPredictions = true
useAtrOffset = false
barPredictionsOffset = 0

// =================================
// ==== Next Bar Classification ====
// =================================

// This model specializes specifically in predicting the direction of price action over the course of the next 4 bars. 
// To avoid complications with the ML model, this value is hardcoded to 4 bars but support for other training lengths may be added in the future.
src = settings.source
y_train_series = src[4] < src[0] ? direction.short : src[4] > src[0] ? direction.long : direction.neutral
var y_train_array = array.new_int(0)

// Variables used for ML Logic
var predictions = array.new_float(0)
var prediction = 0.
var signal = direction.neutral
var distances = array.new_float(0)

array.push(y_train_array, y_train_series)


lastDistance = -1.0
size = math.min(settings.maxBarsBack-1, array.size(y_train_array)-1)
sizeLoop = math.min(settings.maxBarsBack-1, size)

if bar_index >= maxBarsBackIndex //{ 
    for i = 0 to sizeLoop //{
        d = get_lorentzian_distance(i, settings.featureCount, featureSeries, featureArrays) 
        if d >= lastDistance and i%4 //{
            lastDistance := d            
            array.push(distances, d)
            array.push(predictions, math.round(array.get(y_train_array, i)))
            if array.size(predictions) > settings.neighborsCount //{
                lastDistance := array.get(distances, math.round(settings.neighborsCount*3/4))
                array.shift(distances)
                array.shift(predictions)
            //}
        //}
    //}
    prediction := array.sum(predictions)
//}

// ============================
// ==== Prediction Filters ====
// ============================

// User Defined Filters: Used for adjusting the frequency of the ML Model's predictions
filter_all = filter.volatility and filter.regime and filter.adx

// Filtered Signal: The model's prediction of future price movement direction with user-defined filters applied
signal := prediction > 0 and filter_all ? direction.long : prediction < 0 and filter_all ? direction.short : nz(signal[1])

// Bar-Count Filters: Represents strict filters based on a pre-defined holding period of 4 bars
var int barsHeld = 0
barsHeld := ta.change(signal) ? 0 : barsHeld + 1
isHeldFourBars = barsHeld == 4
isHeldLessThanFourBars = 0 < barsHeld and barsHeld < 4

// Fractal Filters: Derived from relative appearances of signals in a given time series fractal/segment with a default length of 4 bars
isDifferentSignalType = ta.change(signal)
isEarlySignalFlip = ta.change(signal) and (ta.change(signal[1]) or ta.change(signal[2]) or ta.change(signal[3]))
isBuySignal = signal == direction.long and isEmaUptrend and isSmaUptrend
isSellSignal = signal == direction.short and isEmaDowntrend and isSmaDowntrend
isLastSignalBuy = signal[4] == direction.long and isEmaUptrend[4] and isSmaUptrend[4]
isLastSignalSell = signal[4] == direction.short and isEmaDowntrend[4] and isSmaDowntrend[4]
isNewBuySignal = isBuySignal and isDifferentSignalType
isNewSellSignal = isSellSignal and isDifferentSignalType

// Kernel Regression Filters: Filters based on Nadaraya-Watson Kernel Regression using the Rational Quadratic Kernel
// For more information on this technique refer to my other open source indicator located here: 
// https://www.tradingview.com/script/AWNvbPRM-Nadaraya-Watson-Rational-Quadratic-Kernel-Non-Repainting/
c_green = color.new(#009988, 20)
c_red = color.new(#CC3311, 20)
transparent = color.new(#000000, 100)
yhat1 = kernels.rationalQuadratic(settings.source, h, r, x)
yhat2 = kernels.gaussian(settings.source, h-lag, x)
kernelEstimate = yhat1
// Kernel Rates of Change
bool wasBearishRate = yhat1[2] > yhat1[1]
bool wasBullishRate = yhat1[2] < yhat1[1]
bool isBearishRate = yhat1[1] > yhat1
bool isBullishRate = yhat1[1] < yhat1
isBearishChange = isBearishRate and wasBullishRate
isBullishChange = isBullishRate and wasBearishRate
// Kernel Crossovers
bool isBullishCrossAlert = ta.crossover(yhat2, yhat1)
bool isBearishCrossAlert = ta.crossunder(yhat2, yhat1) 
bool isBullishSmooth = yhat2 >= yhat1
bool isBearishSmooth = yhat2 <= yhat1
// Kernel Colors
color colorByCross = isBullishSmooth ? c_green : c_red
color colorByRate = isBullishRate ? c_green : c_red
color plotColor = showKernelEstimate ? (useKernelSmoothing ? colorByCross : colorByRate) : transparent
plot(kernelEstimate, color=plotColor, linewidth=2, title="Kernel Regression Estimate")
// Alert Variables
bool alertBullish = useKernelSmoothing ? isBullishCrossAlert : isBullishChange
bool alertBearish = useKernelSmoothing ? isBearishCrossAlert : isBearishChange
// Bullish and Bearish Filters based on Kernel
isBullish = useKernelFilter ? (useKernelSmoothing ? isBullishSmooth : isBullishRate) : true
isBearish = useKernelFilter ? (useKernelSmoothing ? isBearishSmooth : isBearishRate) : true

// ===========================
// ==== Entries and Exits ====
// ===========================

// Entry Conditions: Booleans for ML Model Position Entries
startLongTrade = isNewBuySignal and isBullish and isEmaUptrend and isSmaUptrend
startShortTrade = isNewSellSignal and isBearish and isEmaDowntrend and isSmaDowntrend


// =========================
// ==== Plotting Labels ====
// =========================

// Note: These will not repaint once the most recent bar has fully closed. By default, signals appear over the last closed bar; to override this behavior set offset=0.
plotshape(startLongTrade ? low : na, 'Buy', shape.labelup, location.belowbar, color=ml.color_green(prediction), size=size.small, offset=0)
plotshape(startShortTrade ? high : na, 'Sell', shape.labeldown, location.abovebar, ml.color_red(-prediction), size=size.small, offset=0)















//--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------









//ma indicator code 
allowma = input.bool(false, "Plot MA ", group = 'MA Settings')
matimeframe = input.timeframe("", 'Timeframe for MA', group = 'MA Settings', tooltip = 'be careful when using a lower timeframe, it might not work')  //be careful when using a lower timeframe, it might not work
typeMA = input.string(title = "Method for smoothing", defval = "EMA", options=["SMA", "EMA", "SMMA (RMA)", "WMA", "VWMA"], group="MA Settings")
len1 = input.int(50, minval=1, title="Length", group="MA Settings")
src1 = input(close, title="Source", group="MA Settings")
offset = input.int(title="Offset", defval=0, minval=-500, maxval=500, group="MA Settings")
macolor1 = input.color(color.blue, title="Color of MA", group="MA Settings")

SMA = request.security(syminfo.tickerid, matimeframe, ta.sma(src1, len1))
EMA = request.security(syminfo.tickerid, matimeframe, ta.ema(src1, len1))
SMMA = request.security(syminfo.tickerid, matimeframe, ta.rma(src1, len1))
WMA = request.security(syminfo.tickerid, matimeframe, ta.wma(src1, len1))
VWMA = request.security(syminfo.tickerid, matimeframe, ta.vwma(src1, len1))

out = typeMA == 'EMA' ? EMA : typeMA == 'SMA' ? SMA : typeMA == 'SMMA (RMA)' ? SMMA : typeMA == 'WMA' ? WMA : typeMA == 'VWMA' ? VWMA : 0

plot(allowma ? out:na, title="MA", color=macolor1, offset=offset)









//--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------














//zigzag indicator code
Depth       = input.int(12, "Depth", minval=1, step=1, group="Zigzag Settings (only for SL)")
Deviation   = input.int(5, "Deviation", minval=1, step=1, group="Zigzag Settings (only for SL)")
Backstep    = input.int(3, "Backstep", minval=2, step=1, group="Zigzag Settings (only for SL)")
line_thick  = input.int(2, "Line Thickness", minval=1, maxval=4, group="Zigzag Settings (only for SL)")
upcolor     = input.color(color.new(color.lime, 0), "Color of up zigzag line", group="Zigzag Settings (only for SL)")
dncolor     = input.color(color.new(color.red, 0), "Color of down zigzag line", group="Zigzag Settings (only for SL)")
text_color  = input.color(color.white, "Text color for labels of zigzag", group="Zigzag Settings (only for SL)")
Show_zz     = input.bool(true, "Show Zigzag?", group="Zigzag Settings (only for SL)")
repaint     = input(true, "Repaint Levels", group="Zigzag Settings (only for SL)")


var last_h = 1, last_h := last_h + 1
var last_l = 1, last_l := last_l + 1
var lw = 1, var hg = 1
lw := lw + 1, hg := hg + 1
p_lw = -ta.lowestbars(Depth), p_hg = -ta.highestbars(Depth)
lowing = lw == p_lw or low - low[p_lw] > Deviation*syminfo.mintick
highing = hg == p_hg or high[p_hg] - high > Deviation*syminfo.mintick
lh = ta.barssince(not highing[1]), ll = ta.barssince(not lowing[1])
down = ta.barssince(not (lh > ll)) >= Backstep, lower = low[lw] > low[p_lw], higher = high[hg] < high[p_hg]
if lw != p_lw and (not down[1] or lower)
    lw := p_lw < hg ? p_lw : 0
if hg != p_hg and (down[1] or higher)
    hg := p_hg < lw ? p_hg : 0

line zz = na
label point = na
x1 = down ? lw : hg
y1 = down ? low[lw] : high[hg]

if down == down[1]
    if repaint
        label.delete(point[1])
        line.delete(zz[1])
    down
if down != down[1]
    if down
        last_h := hg
    else
        last_l := lw
    if not repaint
        nx = down?last_h:last_l
        if Show_zz == true
            zz := line.new(bar_index-nx, down ? high[nx] : low[nx], bar_index-(down?last_l:last_h), down ? low[last_l] : high[last_h], width=line_thick, color=down?upcolor:dncolor)
            point := label.new(bar_index-nx, down ? high[nx] : low[nx], down ? (high[nx] > high[last_h[1]]?"HH":"LH") : (low[nx] < low[last_l[1]] ? "LL" : "HL"), style=down?label.style_label_down:label.style_label_up, size=size.tiny, color=down?dncolor:upcolor, textcolor=color.new(text_color, 0), tooltip = down ? (high[nx] > high[last_h[1]]?"Higher High":"Lower High") : (low[nx] < low[last_l[1]] ? "Lower Low" : "Higher Low"))
        
    down
    
if repaint
    if Show_zz == true
        zz := line.new(bar_index-(down?last_h:last_l), down ? high[last_h] : low[last_l], bar_index-x1, y1, width=line_thick, color=down?dncolor:upcolor)
        point := label.new(bar_index-x1, y1, down ? (low[x1] < low[last_l] ? "LL" : "HL") : (high[x1] > high[last_h]?"HH":"LH"), style=down?label.style_label_up:label.style_label_down, size=size.tiny, color=down?upcolor:dncolor, textcolor=color.new(text_color, 0), tooltip = down ? (low[x1] < low[last_l] ? "Lower Low" : "Higher Low") : (high[x1] > high[last_h]?"Higher High":"Lower High"))
// 



//zigzag logic
var float zzUp = 0
var float zzDwn = 0

zzUp := not down ? high[x1] : zzUp[1]
zzDwn := down ? low[x1] : zzDwn[1]











//--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------







var track = 0
var bool swingHigh = false

//ao indicator calculation
ao = ta.sma(hl2,5) - ta.sma(hl2,34)
diff = ao - ao[1]

//zigzag inputs
Depth1       = input.int(144, "Depth1", minval=1, step=1, group="Zigzag Settings (for Divergence)")
Deviation1   = input.int(75, "Deviation1", minval=1, step=1, group="Zigzag Settings (for Divergence)")
Backstep1    = input.int(21, "Backstep1", minval=2, step=1, group="Zigzag Settings (for Divergence)")
line_thick1  = input.int(2, "Line Thickness", minval=1, maxval=4, group="Zigzag Settings (for Divergence)")
upcolor1     = input.color(color.new(color.lime, 0), "Color of up zigzag line", group="Zigzag Settings (for Divergence)")
dncolor1     = input.color(color.new(color.red, 0), "Color of down zigzag line", group="Zigzag Settings (for Divergence)")
text_color1  = input.color(color.white, "Text color for labels of zigzag", group="Zigzag Settings (for Divergence)")
Show_zz1     = input.bool(true, "Show Zigzag?", group="Zigzag Settings (for Divergence)")
repaint1     = input(false, "Repaint Levels", group="Zigzag Settings (for Divergence)")

rbullishcolor     = input.color(color.new(color.lime, 0), "Color of REG bullish divergences", group="Divergence Settings")
rbearishcolor     = input.color(color.new(color.red, 0), "Color of REG bearish divergences", group="Divergence Settings")

hbullishcolor     = input.color(color.new(#2f9c21, 0), "Color of HID bullish divergences", group="Divergence Settings")
hbearishcolor     = input.color(color.new(#861a1a, 0), "Color of HID bearish divergences", group="Divergence Settings")


//zigzag indicator calculation
var last_h1 = 1, last_h1 := last_h1 + 1
var last_l1 = 1, last_l1 := last_l1 + 1
var lw1 = 1, var hg1 = 1
lw1 := lw1 + 1, hg1 := hg1 + 1
p_lw1 = -ta.lowestbars(Depth1), p_hg1 = -ta.highestbars(Depth1)
lowing1 = lw1 == p_lw1 or low - low[p_lw1] > Deviation1*syminfo.mintick
highing1 = hg1 == p_hg1 or high[p_hg1] - high > Deviation1*syminfo.mintick
lh1 = ta.barssince(not highing1[1]), ll1 = ta.barssince(not lowing1[1])
down1 = ta.barssince(not (lh1 > ll1)) >= Backstep1, lower1 = low[lw1] > low[p_lw1], higher1 = high[hg1] < high[p_hg1]
if lw1 != p_lw1 and (not down1[1] or lower1)
    lw1 := p_lw1 < hg1 ? p_lw1 : 0
if hg1 != p_hg1 and (down1[1] or higher1)
    hg1 := p_hg1 < lw1 ? p_hg1 : 0

line zz1 = na
label point1 = na
x11 = down1 ? lw1 : hg1
y11 = down1 ? low[lw1] : high[hg1]

if down1 == down1[1]
    if repaint1
        label.delete(point1[1])
        line.delete(zz1[1])
    down1
if down1 != down1[1]
    if down1
        last_h1 := hg1
    else
        last_l1 := lw1
    if not repaint1
        nx = down1?last_h1:last_l1
        track := bar_index-nx
        swingHigh := down1 ? true: false
        if Show_zz1 == true
            zz1 := line.new(bar_index-nx, down1 ? high[nx] : low[nx], bar_index-(down1?last_l1:last_h1), down1 ? low[last_l1] : high[last_h1], width=line_thick1, color=down1?upcolor1:dncolor1)
            point1 := label.new(bar_index-nx, down1 ? high[nx] : low[nx], down1 ? (high[nx] > high[last_h1[1]]?"HH":"LH") : (low[nx] < low[last_l1[1]] ? "LL" : "HL"), style=down1?label.style_label_down:label.style_label_up, size=size.tiny, color=down1?dncolor1:upcolor1, textcolor=color.new(text_color1, 0), tooltip = down1 ? (high[nx] > high[last_h1[1]]?"Higher High":"Lower High") : (low[nx] < low[last_l1[1]] ? "Lower Low" : "Higher Low"))

    down1
    
if repaint1
    track := bar_index-x11
    swingHigh := down1 ? false: true
    if Show_zz1 == true
        zz1 := line.new(bar_index-(down1?last_h1:last_l1), down1 ? high[last_h1] : low[last_l1], bar_index-x11, y11, width=line_thick1, color=down1?dncolor1:upcolor1)
        point1 := label.new(bar_index-x11, y11, down1 ? (low[x11] < low[last_l1] ? "LL" : "HL") : (high[x11] > high[last_h1]?"HH":"LH"), style=down1?label.style_label_up:label.style_label_down, size=size.tiny, color=down1?upcolor1:dncolor1, textcolor=color.new(text_color1, 0), tooltip = down1 ? (low[x11] < low[last_l1] ? "Lower Low" : "Higher Low") : (high[x11] > high[last_h1]?"Higher High":"Lower High"))
        
// 









//--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------














//ao logic

bool lookingForBull = false
bool lookingForBear = false

float curr_lowest = 0
int bullStart = 0
float curr_highest = 0
int bearStart = 0

var int bearishTrendlineStart = 0
var int bullishTrendlineStart = 0

var latestBullLine = line(na)
var bullLineCounter = -1
var latestBearLine = line(na)
var bearLineCounter = -1

//for regular div entry condition
var float rBullLow2 = 0
var float rBearHigh2 = 0

var int rBullLow2Bar = 0
var int rBearHigh2Bar = 0


//for divergence entry conditions
var int buyBarIndex = 0
var int sellBarIndex = 0



//to find where the ao range starts (the bar at which the ao first started being negative)
findBuyStartPoint() =>
    int shift = 0

    int i = 0
    while ao[i] < 0 
        shift := i
        i := i + 1
    //

    shift 
//

//to find the lowest ao in the current range (starting from its shift 0 upto the start of the range)
findLowestAo(int start) =>
    float lowest = 0
    int end = bar_index - start

    for i = 0 to end
        if ao[i] < lowest
            lowest := ao[i]
    //

    lowest
//

//to find lowest low (in price) in a given ao range 
findLowestPrice(int start, int end) =>
    int endShift = bar_index - end
    int startShift = bar_index - start
    float lowest = low[startShift]
    int barTime = 0
    
    for i = startShift to endShift 
        if low[i] < lowest
            lowest := low[i]
            barTime := i
        //
    //

    [lowest, barTime]
// 

//to find lowest low (in price) in a given price range for updating the trendline
findLowest(int start, int end) =>
    int endShift = end
    int startShift = start
    float lowest = low[startShift]
    int barTime = 0
    
    for i = startShift to endShift 
        if low[i] < lowest
            lowest := low[i]
            barTime := i
        //
    //

    [lowest, barTime]
// 

//------------------------------------------------------------------------------------------------------------------------------------


//to find where the ao range starts (the bar at which the ao first started being negative)
findSellStartPoint() =>
    int shift = 0

    int i = 0
    while ao[i] > 0 
        shift := i
        i := i + 1
    //

    shift 
//

//to find the lowest ao in the current range (starting from its shift 0 upto the start of the range)
findHighestAo(int start) =>
    float highest = 0
    int end = bar_index - start

    for i = 0 to end
        if ao[i] > highest
            highest := ao[i]
    //

    highest
//

//to find lowest low (in price) in a given range 
findHighestPrice(int start, int end) =>
    int endShift = bar_index - end
    int startShift = bar_index - start
    float highest = high[startShift]
    int barTime = 0
    
    for i = startShift to endShift 
        if high[i] > highest
            highest := high[i]
            barTime := i
        //
    //

    [highest, barTime]
// 

//to find lowest low (in price) in a given price range for updating the trendline
findHighest(int start, int end) =>
    int endShift = end
    int startShift = start
    float highest = high[startShift]
    int barTime = 0
    
    for i = startShift to endShift 
        if high[i] > highest
            highest := high[i]
            barTime := i
        //
    //

    [highest, barTime]
// 






//------------------------------------------------------------------------------------------------------------------------------------







//for bullish divergences

bullStart := bar_index - findBuyStartPoint()
curr_lowest := findLowestAo(bullStart)

var minRangesLowest = array.new_float(0)
var minRangesEnd = array.new_int(0)
var minRangesStart = array.new_int(0)

var int lowestIndex = -1
var float lowestVal = 0
var int lowestStart = -1

//start afresh when there is a a zigzag down
if not swingHigh
    bullStart := 0
    curr_lowest := 0
    array.clear(minRangesLowest)
    array.clear(minRangesEnd)
    array.clear(minRangesStart)
    lowestIndex := -1
    lowestVal := 0
    lowestStart := -1
//


if swingHigh
    if ao < 0
        lookingForBull := true
//
            


//storing the lowest value, start shift & end shift of the current range & updating it as values change
if lookingForBull == true  
    int lastIndex = array.size(minRangesStart) - 1

    if array.size(minRangesStart) >= 1 
        if array.get(minRangesStart, lastIndex) != bullStart
            array.push(minRangesStart, 0)
            array.push(minRangesEnd, 0)
            array.push(minRangesLowest, 0)
        //
    //

    if array.size(minRangesStart) == 0
        array.push(minRangesStart, 0)
        array.push(minRangesEnd, 0)
        array.push(minRangesLowest, 0)
    //

    lastIndex := array.size(minRangesStart)-1
    array.set(minRangesLowest, lastIndex, curr_lowest) //set the lowest value for the current range
    array.set(minRangesStart, lastIndex, bullStart) //set the start shift for the current range
    array.set(minRangesEnd, lastIndex, bar_index) //set the end shift for the current range
//


//checking if there is more than 1 range to compare with the lowest ao val up untill the current bar
if array.size(minRangesStart) >= 1 
    int lastIndex = array.size(minRangesStart) - 1

    if array.get(minRangesLowest, lastIndex) < lowestVal
        lowestVal := array.get(minRangesLowest, lastIndex)
        lowestIndex := lastIndex
    //
//


//checking if there are more than 2 ranges to compare/ delete lines
if array.size(minRangesStart) >= 2 

    int lastIndex = array.size(minRangesStart) - 1

    //get the start and end shifts of the 2 ranges
    int start2 = array.get(minRangesStart, lastIndex)
    int end2 = array.get(minRangesEnd, lastIndex)

    int start1 = array.get(minRangesStart, lowestIndex)
    int end1 = array.get(minRangesEnd, lowestIndex)

    //if lowest in range 2 is greater than lowest in range 1
    if array.get(minRangesLowest, lastIndex) > lowestVal
        [lowest1, index1] = findLowestPrice(start1, end1)
        [lowest2, index2] = findLowestPrice(start2, end2)

        //check if lowest price in range 1 > lowest price in range 2
        if lowest1 > lowest2 

            if lowestStart != start1
                latestBullLine := line.new(time[index2], lowest2, time[index1], lowest1, xloc = xloc.bar_time, extend = extend.none, color = rbullishcolor, style = line.style_solid, width = 1)
                bullLineCounter := bullLineCounter + 1
                lowestStart := start1
            //

            if lowestStart == start1

                //to find the lowest low from the start of trendline to current bar
                [currLowest, currLowestIndex] = findLowest(index1, 0)
                
                line.set_x1(latestBullLine, time[currLowestIndex])
                line.set_y1(latestBullLine, currLowest)

                //storing these values for entry condition
                rBullLow2Bar := bar_index - currLowestIndex
                rBullLow2 := currLowest
            //

        //

    //

//






//for bearish divergences

bearStart := bar_index - findSellStartPoint()
curr_highest := findHighestAo(bearStart)

var maxRangesHighest = array.new_float(0)
var maxRangesEnd = array.new_int(0)
var maxRangesStart = array.new_int(0)

var int highestIndex = -1
var float highestVal = 0
var int highestStart = -1


//start afresh when there is a a zigzag up
if swingHigh
    bearStart := 0
    curr_highest := 0
    array.clear(maxRangesHighest)
    array.clear(maxRangesEnd)
    array.clear(maxRangesStart)
    highestIndex := -1
    highestVal := 0
    highestStart := -1
//


if not swingHigh
    if ao > 0 
        lookingForBear := true
//
            


//storing the highest value, start shift & end shift of the current range & updating it as values change
if lookingForBear == true 
    int lastIndex = array.size(maxRangesStart) - 1

    if array.size(maxRangesStart) >= 1 
        if array.get(maxRangesStart, lastIndex) != bearStart
            array.push(maxRangesStart, 0)
            array.push(maxRangesEnd, 0)
            array.push(maxRangesHighest, 0)
        //
    //

    if array.size(maxRangesStart) == 0
        array.push(maxRangesStart, 0)
        array.push(maxRangesEnd, 0)
        array.push(maxRangesHighest, 0)
    //

    lastIndex := array.size(maxRangesStart)-1
    array.set(maxRangesHighest, lastIndex, curr_highest) //set the highest value for the current range
    array.set(maxRangesStart, lastIndex, bearStart) //set the start shift for the current range
    array.set(maxRangesEnd, lastIndex, bar_index) //set the end shift for the current range
//


//checking if there is more than 1 range to compare with the highest ao val up untill the current bar
if array.size(maxRangesStart) >= 1 
    int lastIndex = array.size(maxRangesStart) - 1

    if array.get(maxRangesHighest, lastIndex) > highestVal
        highestVal := array.get(maxRangesHighest, lastIndex)
        highestIndex := lastIndex
    //
//


//checking if there are more than 2 ranges to compare/ delete lines
if array.size(maxRangesStart) >= 2  

    int lastIndex = array.size(maxRangesStart) - 1
    
    //get the start and end shifts of the 2 ranges
    int start2 = array.get(maxRangesStart, lastIndex)
    int end2 = array.get(maxRangesEnd, lastIndex)

    int start1 = array.get(maxRangesStart, highestIndex)
    int end1 = array.get(maxRangesEnd, highestIndex)

    //if highest in range 2 is lower than highest in range 1
    if array.get(maxRangesHighest, lastIndex) < highestVal
        [highest1, index1] = findHighestPrice(start1, end1)
        [highest2, index2] = findHighestPrice(start2, end2)

        //check if highest price in range 1 < highest price in range 2
        if highest1 < highest2 

            if highestStart != start1
                latestBearLine := line.new(time[index2], highest2, time[index1], highest1, xloc = xloc.bar_time, extend = extend.none, color = rbearishcolor, style = line.style_solid, width = 1)
                bearLineCounter := bearLineCounter + 1
                highestStart := start1
            //

            if highestStart == start1
                
                //to find the highest high from the start of trendline to current bar
                [currHighest, currHighestIndex] = findHighest(index1, 0)

                line.set_x1(latestBearLine, time[currHighestIndex])
                line.set_y1(latestBearLine, currHighest)

                //storing these values for entry condition
                rBearHigh2Bar := bar_index - currHighestIndex
                rBearHigh2 := currHighest
            //

        //

    //

//













//--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------






//FOR BULLISH HIDDDEN DIVERGENCE



//VARIABLES FOR HIDDEN DIV

bool lookingForBull2 = false

float curr_lowest2 = 0
int bullStart2 = 0

var minRangesLowest2 = array.new_float(0)
var minRangesHighest2 = array.new_float(0)
var minRangesEnd2 = array.new_int(0)
var minRangesStart2 = array.new_int(0)

var int lowestIndex2 = -1
var int highestLowestIndex2 = -1

var float lowestVal2 = 0
var float highestLowestVal2 = -100000

var int highestStartHid2 = -1


//for hidden div entry condition
var float hBullLow1 = 0
var float hBearHigh1 = 0

var float hBullLow2 = 0
var float hBearHigh2 = 0

var int hBearHigh2Bar = 0
var int hBullLow2Bar = 0



//LOGIC FOR HIDDEN DIV

bullStart2 := bar_index - findBuyStartPoint()

float lowest = 0
int end = bar_index - bullStart2

for i = 0 to end
    if ao[i] < lowest
        lowest := ao[i]
//
curr_lowest2 := lowest

//start afresh when there is a a zigzag down
if swingHigh
    bullStart2 := 0
    curr_lowest2 := 0
    array.clear(minRangesLowest2)
    array.clear(minRangesEnd2)
    array.clear(minRangesStart2)
    lowestIndex2 := -1
    highestLowestIndex2 := -1
    lowestVal2 := 0
    highestLowestVal2 := -100000
    highestStartHid2 := -1
//


if not swingHigh
    if ao < 0
        lookingForBull2 := true
//


//storing the lowest value, start shift & end shift of the current range & updating it as values change
if lookingForBull2 == true  
    int lastIndex = array.size(minRangesStart2) - 1

    if array.size(minRangesStart2) >= 1  //if there are elements in the arrays already, 
        if array.get(minRangesStart2, lastIndex) != bullStart2 //and a new range has started, push new elements in the arrays which are made for that range specifically
            array.push(minRangesStart2, 0)
            array.push(minRangesEnd2, 0)
            array.push(minRangesLowest2, 0)
        //
    //

    if array.size(minRangesStart2) == 0  //if there is nothing in the array, push a new element in to store values
        array.push(minRangesStart2, 0)
        array.push(minRangesEnd2, 0)
        array.push(minRangesLowest2, 0)
    //

    lastIndex := array.size(minRangesStart2)-1
    array.set(minRangesLowest2, lastIndex, curr_lowest2) //set the lowest value for the current range
    array.set(minRangesStart2, lastIndex, bullStart2) //set the start shift for the current range
    array.set(minRangesEnd2, lastIndex, bar_index) //set the end shift for the current range
//


if array.size(minRangesLowest2) >= 2 and ao[1] < ao and ao >= 0
    int lastIndex = array.size(minRangesLowest2) - 1

    //only compare the lowest value of R2 (current range) with lowest value of R1 (previous range) once R2 is complete
    if array.get(minRangesLowest2, lastIndex) > array.get(minRangesLowest2, lastIndex- 1) and array.get(minRangesLowest2, lastIndex) > highestLowestVal2 //checking if there is a higher low in the current range
        highestLowestVal2 := array.get(minRangesLowest2, lastIndex)
        highestLowestIndex2 := lastIndex
    //
//


bool bullHidDiv = false
float _lowest1 = 0, float _lowest2 = 0


if array.size(minRangesLowest2) >= 2 and highestLowestIndex2 >= 0

    int lastIndex = array.size(minRangesLowest2) - 1
    
    //get the start and end shifts of the 2 ranges
    int start2 = array.get(minRangesStart2, lastIndex)
    int end2 = array.get(minRangesEnd2, lastIndex)

    int start1 = array.get(minRangesStart2, highestLowestIndex2)
    int end1 = array.get(minRangesEnd2, highestLowestIndex2)

    //if lowest in range 2 is lesser than lowest in range 1
    if array.get(minRangesLowest2, lastIndex) < highestLowestVal2 and highestLowestIndex2 < lastIndex

        int endShift = bar_index - end1
        int startShift = bar_index - start1
        int index1 = 0
        _lowest1 := low[startShift]
        
        //DO NOT CHANGE THE WAY THE 2ND IF CONDITION IS WRITTEN, BECAUSE IT ONLY WORKS THIS WAY... I DONT KNOW WHY THOUGH
        for i = startShift to endShift
            if low[i] < _lowest1
                _lowest1 := low[i]
            //

            if low[i] <= _lowest1
                index1 := i
            //
        //

        endShift := bar_index - end2
        startShift := bar_index - start2
        int index2 = 0
        _lowest2 := low[startShift]
        
        //DO NOT CHANGE THE WAY THE 2ND IF CONDITION IS WRITTEN, BECAUSE IT ONLY WORKS THIS WAY... I DONT KNOW WHY THOUGH
        for i = endShift to startShift

            if low[i] < _lowest2
                _lowest2 := low[i]
            //

            if low[i] <= _lowest2
                index2 := i
            //
        //


        //check if lowest price in range 1 < lowest price in range 2
        if _lowest1 < _lowest2 
            bullHidDiv := true
            line.new(time[index1], _lowest1, time[index2], _lowest2, xloc = xloc.bar_time, extend = extend.none, color = hbullishcolor, style = line.style_solid, width = 1)
        //

        //storing these values for entry condition
        hBullLow2 := _lowest2
        hBullLow1 := _lowest1
        hBullLow2Bar := bar_index - index2
    //
//












//FOR BEARISH HIDDDEN DIVERGENCE



//VARIABLES FOR HIDDEN DIV

bool lookingForBear2 = false

float curr_highest2 = 0
int bearStart2 = 0

var maxRangesHighest2 = array.new_float(0)
var maxRangesLowest2 = array.new_float(0)
var maxRangesEnd2 = array.new_int(0)
var maxRangesStart2 = array.new_int(0)

var int highestIndex2 = -1
var int lowestHighestIndex2 = -1

var float lowestHighestVal2 = 100000

var int lowestStartHid2 = -1



//LOGIC FOR HIDDEN DIV

bearStart2 := bar_index - findSellStartPoint()

float highest = 0
int end3 = bar_index - bearStart2

for i = 0 to end3
    if ao[i] > highest
        highest := ao[i]
//
curr_highest2 := highest

//start afresh when there is a a zigzag down
if not swingHigh
    bearStart2 := 0
    curr_highest2 := 0
    array.clear(maxRangesHighest2)
    array.clear(maxRangesEnd2)
    array.clear(maxRangesStart2)
    highestIndex2 := -1
    lowestHighestIndex2 := -1
    lowestHighestVal2 := 100000
    lowestStartHid2 := -1
//


if swingHigh
    if ao > 0
        lookingForBear2 := true
//


//storing the highest value, start shift & end shift of the current range & updating it as values change
if lookingForBear2 == true  
    int lastIndex = array.size(maxRangesStart2) - 1

    if array.size(maxRangesStart2) >= 1  //if there are elements in the arrays already, 
        if array.get(maxRangesStart2, lastIndex) != bearStart2 //and a new range has started, push new elements in the arrays which are made for that range specifically
            array.push(maxRangesStart2, 0)
            array.push(maxRangesEnd2, 0)
            array.push(maxRangesHighest2, 0)
        //
    //

    if array.size(maxRangesStart2) == 0  //if there is nothing in the array, push a new element in to store values
        array.push(maxRangesStart2, 0)
        array.push(maxRangesEnd2, 0)
        array.push(maxRangesHighest2, 0)
    //

    lastIndex := array.size(maxRangesStart2)-1
    array.set(maxRangesHighest2, lastIndex, curr_highest2) //set the highest value for the current range
    array.set(maxRangesStart2, lastIndex, bearStart2) //set the start shift for the current range
    array.set(maxRangesEnd2, lastIndex, bar_index) //set the end shift for the current range
//


if array.size(maxRangesHighest2) >= 2 and ao[1] > ao and ao < 0
    int lastIndex = array.size(maxRangesHighest2) - 1

    //only compare the highest value of R2 (current range) with highest value of R1 (previous range) once R2 is complete
    if array.get(maxRangesHighest2, lastIndex) < array.get(maxRangesHighest2, lastIndex- 1) and array.get(maxRangesHighest2, lastIndex) < lowestHighestVal2 //checking if there is a lower high in the current range
        lowestHighestVal2 := array.get(maxRangesHighest2, lastIndex)
        lowestHighestIndex2 := lastIndex
    //
//


bool bearHidDiv = false
float _highest1 = 0, float _highest2 = 0


if array.size(maxRangesHighest2) >= 2 and lowestHighestIndex2 >= 0

    int lastIndex = array.size(maxRangesHighest2) - 1
    
    //get the start and end shifts of the 2 ranges
    int start2 = array.get(maxRangesStart2, lastIndex)
    int end2 = array.get(maxRangesEnd2, lastIndex)

    int start1 = array.get(maxRangesStart2, lowestHighestIndex2)
    int end1 = array.get(maxRangesEnd2, lowestHighestIndex2)

    //if highest in range 2 is greater than highest in range 1
    if array.get(maxRangesHighest2, lastIndex) > lowestHighestVal2 and lowestHighestIndex2 < lastIndex

        int startShift = bar_index - start1
        int endShift = bar_index - end1
        int _index1 = 0
        _highest1 := high[startShift]

        for i = startShift to endShift 
            if high[i] > _highest1
                _highest1 := high[i]
            //

            if high[i] >= _highest1
                _index1 := i
            //
        //

        startShift := bar_index - start2
        endShift := bar_index - end2
        int _index2 = 0
        _highest2 := high[startShift]

        for i = startShift to endShift 
            if high[i] > _highest2
                _highest2 := high[i]
            //

            if high[i] >= _highest2
                _index2 := i
            //
        //


        //check if highest price in range 1 < highest price in range 2
        if _highest1 > _highest2 
            bearHidDiv := true
            line.new(time[_index1], _highest1, time[_index2], _highest2, xloc = xloc.bar_time, extend = extend.none, color = hbearishcolor, style = line.style_solid, width = 1)
        //

        //storing these values for entry condition
        hBearHigh2 := _highest2
        hBearHigh1 := _highest1
        hBearHigh2Bar := bar_index - _index2

    //
//









//--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------





//for checking if atleast 1 entry condition (except divergence entry conditions) is true 
checkIfTrue(bool cond1, bool cond2, bool cond3) => cond1 or cond2 or cond3 







//--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
//BUY ENTRY CONDITIONS

//entry condition for price to close above ma 
bool bullishPriceClose = (close[entryShiftInput] > out and priceCloseEntryInput) or not priceCloseEntryInput
bool bullishPriceCloseTrue = (close[entryShiftInput] > out and priceCloseEntryInput) 

//entry condition for low to be below either ma
bool bullishPriceExt = (low[entryShiftInput] < out and priceExtEntryInput) or not priceExtEntryInput
bool bullishPriceExtTrue = (low[entryShiftInput] < out and priceExtEntryInput) 

//entry condition for LC Label to come at x shift
bool LorenBuy = (startLongTrade[entryShiftInput] == true and lorenzeEntryInput) or not lorenzeEntryInput
bool LorenBuyTrue = (startLongTrade[entryShiftInput] == true and lorenzeEntryInput) 

int shift = divShiftInput - 1
int barsLater = rBullLow2Bar + shift

//entry condition for ao regular divergence0
bool bullishRNotFar = (rBearHigh2Bar < rBullLow2Bar and sellBarIndex < rBullLow2Bar and not lorenzeEntryInput) or lorenzeEntryInput
bool bullishRDivLoren = (LorenBuyTrue and rDivEntryInput and bar_index - entryShiftInput >= rBullLow2Bar and bar_index - entryShiftInput <= barsLater) or not (lorenzeEntryInput and rDivEntryInput)
//"bullishPriceClose and bullishPriceExt and LorenBuy" to make sure that all the selected entries are true & "checkIfTrue(bullishPriceCloseTrue, bullishPriceExtTrue, LorenBuyTrue)" to make sure that atleast 1 other entry condition is true
bool bullishRDiv = (rDivEntryInput and bullishPriceClose and bullishPriceExt and LorenBuy and bullishRNotFar and checkIfTrue(bullishPriceCloseTrue, bullishPriceExtTrue, LorenBuyTrue) and (ta.lowestbars(low, (bar_index - rBullLow2Bar)+ 1) * -1) == bar_index - rBullLow2Bar) or not rDivEntryInput

shift := divShiftInput - 1
barsLater := hBullLow2Bar + shift

//entry condition for ao hidden divergence0
bool bullishHNotFar = (hBearHigh2Bar < hBullLow2Bar and sellBarIndex < hBullLow2Bar and not lorenzeEntryInput) or lorenzeEntryInput
bool bullishHDivLoren = (LorenBuyTrue and hDivEntryInput and bar_index - entryShiftInput >= hBullLow2Bar and bar_index - entryShiftInput <= barsLater) or not (lorenzeEntryInput and hDivEntryInput)
//"bullishPriceClose and bullishPriceExt and LorenBuy" to make sure that all the selected entries are true & "checkIfTrue(bullishPriceCloseTrue, bullishPriceExtTrue, LorenBuyTrue)" to make sure that atleast 1 other entry condition is true
bool bullishHDiv = (hDivEntryInput and bullHidDiv and bullishPriceClose and bullishPriceExt and LorenBuy and bullishHNotFar and checkIfTrue(bullishPriceCloseTrue, bullishPriceExtTrue, LorenBuyTrue) and (ta.lowestbars(low, (bar_index - hBullLow2Bar)+ 1) * -1) == bar_index - hBullLow2Bar) or not hDivEntryInput















//--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
//SELL ENTRY CONDITIONS

//entry condition for price to close below ma 
bool bearishPriceClose = (close[entryShiftInput] < out and priceCloseEntryInput) or not priceCloseEntryInput
bool bearishPriceCloseTrue = (close[entryShiftInput] < out and priceCloseEntryInput) 

//entry condition for high to be above ma
bool bearishPriceExt = (high[entryShiftInput] > out and priceExtEntryInput) or not priceExtEntryInput
bool bearishPriceExtTrue = (high[entryShiftInput] > out and priceExtEntryInput) 

//entry condition for LC Label to come at x shift
bool LorenSell = (startShortTrade[entryShiftInput] == true and lorenzeEntryInput) or not lorenzeEntryInput
bool LorenSellTrue = (startShortTrade[entryShiftInput] == true and lorenzeEntryInput) 

shift := divShiftInput - 1
barsLater := rBearHigh2Bar + shift

//entry condition for ao regular divergence
bool bearishRNotFar = (rBullLow2Bar < rBearHigh2Bar and buyBarIndex < rBearHigh2Bar and not lorenzeEntryInput) or lorenzeEntryInput
bool bearishRDivLoren = (LorenSellTrue and rDivEntryInput and bar_index - entryShiftInput >= rBearHigh2Bar and bar_index - entryShiftInput <= barsLater) or not (lorenzeEntryInput and rDivEntryInput)
//"bearishPriceClose and bearishPriceExt and LorenSell" to make sure that all the selected entries are true & "checkIfTrue(bearishPriceCloseTrue, bearishPriceExtTrue, LorenSellTrue)" to make sure that atleast 1 other entry condition is true
bool bearishRDiv = (rDivEntryInput and bearishPriceClose and bearishPriceExt and LorenSell and bearishRNotFar and checkIfTrue(bearishPriceCloseTrue, bearishPriceExtTrue, LorenSellTrue) and (ta.highestbars(high, (bar_index - rBearHigh2Bar)+ 1) * -1) == bar_index - rBearHigh2Bar) or not rDivEntryInput

shift := divShiftInput - 1
barsLater := hBearHigh2Bar + shift

//entry condition for ao hidden divergence
bool bearishHNotFar = (hBullLow2Bar < hBearHigh2Bar and buyBarIndex < hBearHigh2Bar and not lorenzeEntryInput) or lorenzeEntryInput
bool bearishHDivLoren = (LorenSellTrue and hDivEntryInput and bar_index - entryShiftInput >= hBearHigh2Bar and bar_index - entryShiftInput <= barsLater) or not (lorenzeEntryInput and hDivEntryInput)
//"bearishPriceClose and bearishPriceExt and LorenSell" to make sure that all the selected entries are true & "checkIfTrue(bearishPriceCloseTrue, bearishPriceExtTrue, LorenSellTrue)" to make sure that atleast 1 other entry condition is true
bool bearishHDiv = (hDivEntryInput and bearHidDiv and bearishPriceClose and bearishPriceExt and LorenSell and bearishHNotFar and checkIfTrue(bearishPriceCloseTrue, bearishPriceExtTrue, LorenSellTrue) and (ta.highestbars(high, (bar_index - hBearHigh2Bar)+ 1) * -1) == bar_index - hBearHigh2Bar) or not hDivEntryInput






 








//--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
//ENTRY
var float buySL = 0
var float sellSL = 0
var float buyTP = 0
var float sellTP = 0
float entry_price = strategy.opentrades.entry_price(strategy.opentrades - 1)

bool sltpExit = strategy.opentrades == 0 and useSLTPExitInput and not oppositeTradeExitInput
bool closeCondExit = oppositeTradeExitInput and not useSLTPExitInput
bool bothExit = useSLTPExitInput and oppositeTradeExitInput

bool check1 = false

//sell entry
if bearishPriceClose and bearishPriceExt and LorenSell and bearishRDiv and bearishRDivLoren and bearishHDiv and bearishHDivLoren and (sltpExit or closeCondExit or bothExit)
    strategy.entry(id="sell entry", direction=strategy.short, qty = lotsInput)
    entry_price := strategy.opentrades.entry_price(strategy.opentrades - 1)
    sellBarIndex := bar_index

    if oppositeTradeExitInput
        strategy.close("buy entry", qty_percent = 100, immediately = true)
        check1 := true
//


//sl & tp for sell
//this might not work because there might hv been a new trade on the previous bar, if that is so, it wont set the tp or sl
if (strategy.opentrades[1] == 0 and strategy.opentrades[0] == 1 and strategy.position_size < 0 and useSLTPExitInput) or (check1 == true and useSLTPExitInput and strategy.opentrades[0] == 1 and strategy.opentrades[1] == 0)
    sellSL := useZZSLExitInput ? zzUp : useRDivSLExitInput ? rBearHigh2 : useH1DivSLExitInput ? hBearHigh1 : useH2DivSLExitInput ? hBearHigh2 : 0
    sellTP := entry_price - ((sellSL > entry_price ? sellSL - entry_price : entry_price - sellSL) * tpRatioInput)
    
//


//to visualize tp and sl levels only for single trades because it only works for that
plot(strategy.position_size < 0 and useSLTPExitInput ? sellSL : na, 'Sell sl', color = color.red, style = plot.style_linebr)
plot(strategy.position_size < 0 and useSLTPExitInput ? sellTP : na, 'Sell tp', color = color.lime, style = plot.style_linebr)

//exiting sell trades
if strategy.opentrades.size(strategy.opentrades - 1) < 0
    if useSLTPExitInput
        strategy.exit('sell exit', "sell entry", stop = sellSL, limit = sellTP, comment_loss = 'sl hit', comment_profit = 'tp hit')
    //
//


//-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------



bool check3 = false

//buy entry
if bullishPriceClose and bullishPriceExt and LorenBuy and bullishRDiv and bullishRDivLoren and bullishHDiv and bullishHDivLoren and (sltpExit or closeCondExit or bothExit)
    strategy.entry(id="buy entry", direction=strategy.long, qty = lotsInput)
    entry_price := strategy.opentrades.entry_price(strategy.opentrades - 1)
    buyBarIndex := bar_index

    if oppositeTradeExitInput
        strategy.close("sell entry", qty_percent = 100, immediately = true)
        check3 := true
//

//sl & tp for buy
//this might not work because there might hv been a new trade on the previous bar, if that is so, it wont set the tp or sl
if (strategy.opentrades[1] == 0 and strategy.opentrades[0] == 1 and strategy.position_size > 0 and useSLTPExitInput) or (check3 == true and useSLTPExitInput and strategy.opentrades[0] == 1 and strategy.opentrades[1] == 0)
    buySL := useZZSLExitInput ? zzDwn : useRDivSLExitInput ? rBullLow2 : useH1DivSLExitInput ? hBullLow1 : useH2DivSLExitInput ? hBullLow2 : 0
    buyTP := entry_price + ((entry_price > buySL ? entry_price - buySL : buySL - entry_price) * tpRatioInput)
//


//to visualize tp and sl levels only for single trades because it only works for that
plot(strategy.position_size > 0 and useSLTPExitInput ? buySL : na, 'Buy sl', color = color.red, style = plot.style_linebr)
plot(strategy.position_size > 0 and useSLTPExitInput ? buyTP : na, 'Buy tp', color = color.lime, style = plot.style_linebr)

//exiting buy trades
if strategy.opentrades.size(strategy.opentrades - 1) > 0
    if useSLTPExitInput
        strategy.exit('buy exit', "buy entry", stop = buySL, limit = buyTP, comment_loss = 'sl hit', comment_profit = 'tp hit')
    //
//
//








